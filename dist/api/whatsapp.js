"use strict";
/*
 * This file is part of WPPConnect.
 *
 * WPPConnect is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * WPPConnect is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with WPPConnect.  If not, see <https://www.gnu.org/licenses/>.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Whatsapp = void 0;
const axios_1 = __importDefault(require("axios"));
const WAuserAgente_1 = require("../config/WAuserAgente");
const helpers_1 = require("./helpers");
const decrypt_1 = require("./helpers/decrypt");
const business_layer_1 = require("./layers/business.layer");
const fs = __importStar(require("fs"));
const sleep_1 = require("../utils/sleep");
class Whatsapp extends business_layer_1.BusinessLayer {
    constructor(page, session, options) {
        super(page, session, options);
        this.page = page;
        this.connected = null;
        this.downloadEncryptedFile = async (url, outputPath, retries = 3) => {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    const response = await axios_1.default.get(url, (0, decrypt_1.makeOptions)(WAuserAgente_1.useragentOverride, 'stream'));
                    await new Promise((resolve, reject) => {
                        const writer = fs.createWriteStream(outputPath);
                        response.data.pipe(writer);
                        writer.on('finish', resolve);
                        writer.on('error', reject);
                    });
                    console.log(`Encrypted file downloaded at ${outputPath}`);
                    return;
                }
                catch (error) {
                    console.error(`Attempt ${attempt} failed: `, error.message);
                    if (attempt === retries) {
                        console.error(`${outputPath} - All attempt failed to download the file: ${url}`);
                        throw error;
                    }
                    console.log(`${outputPath} - Retrying to download the file: ${url} in 5 seconds...`);
                    await (0, sleep_1.sleep)(5000);
                }
            }
        };
        let interval = null;
        if (this.page) {
            this.page.on('close', async () => {
                clearInterval(interval);
            });
        }
        interval = setInterval(async () => {
            const newConnected = await page
                .evaluate(() => WPP.conn.isRegistered())
                .catch(() => null);
            if (newConnected === null || newConnected === this.connected) {
                return;
            }
            this.connected = newConnected;
            if (!newConnected) {
                this.log('info', 'Session Unpaired', { type: 'session' });
                setTimeout(async () => {
                    if (this.statusFind) {
                        try {
                            this.statusFind('disconnectedMobile', session);
                        }
                        catch (error) { }
                    }
                }, 1000);
            }
        }, 1000);
    }
    async afterPageScriptInjected() {
        await super.afterPageScriptInjected();
        this.page
            .evaluate(() => WPP.conn.isRegistered())
            .then((isAuthenticated) => {
            this.connected = isAuthenticated;
        })
            .catch(() => null);
    }
    /**
     * Decrypts message file
     * @param data Message object
     * @returns Decrypted file buffer (null otherwise)
     */
    async downloadFile(data) {
        return await (0, helpers_1.evaluateAndReturn)(this.page, (data) => WAPI.downloadFile(data), data);
    }
    /**
     * Download and returns the media content in base64 format
     * @param messageId Message or id
     * @returns Base64 of media
     */
    async downloadMedia(messageId) {
        if (typeof messageId !== 'string') {
            messageId = messageId.id;
        }
        return await (0, helpers_1.evaluateAndReturn)(this.page, async (messageId) => WPP.util.blobToBase64(await WPP.chat.downloadMedia(messageId)), messageId);
    }
    /**
     * Get the puppeteer page instance
     * @returns The Whatsapp page
     */
    get waPage() {
        return this.page;
    }
    /**
     * Get the puppeteer page screenshot
     * @returns The Whatsapp page screenshot as a PNG encoded in base64 (not the full data URI, just the base64 section)
     */
    async takeScreenshot() {
        if (this.page) {
            return await this.page.screenshot({ encoding: 'base64' });
        }
    }
    /**
     * Clicks on 'use here' button (When it gets unlaunched)
     * This method tracks the class of the button
     * WhatsApp Web might change this class name over time
     * Don't rely on this method
     */
    async useHere() {
        return await (0, helpers_1.evaluateAndReturn)(this.page, () => WAPI.takeOver());
    }
    /**
     * Log out of WhatsApp
     * @returns boolean
     */
    async logout() {
        return await (0, helpers_1.evaluateAndReturn)(this.page, () => WPP.conn.logout());
    }
    /**
     * Closes page and browser
     * @internal
     */
    async close() {
        const browser = this.page.browser();
        if (!this.page.isClosed()) {
            await this.page.close().catch(() => null);
            await browser.close().catch(() => null);
            /*
            Code was removed as it is not necessary.
            try {
              const process = browser.process();
              if (process) {
                treekill(process.pid, 'SIGKILL');
              }
            } catch (error) {}
            */
        }
        return true;
    }
    /**
     * Return PID process
     * @internal
     */
    getPID() {
        const browser = this.page.browser();
        const process = browser.process();
        return process.pid;
    }
    /**
     * Get a message by its ID
     * @param messageId string
     * @returns Message object
     */
    async getMessageById(messageId) {
        return (await (0, helpers_1.evaluateAndReturn)(this.page, (messageId) => WAPI.getMessageById(messageId), messageId));
    }
    /**
     * Returns a list of messages from a chat
     * @param chatId string ID of the conversation or group
     * @param params GetMessagesParam Result filtering options (count, id, direction) see {@link GetMessagesParam}.
     * @returns Message object
     */
    async getMessages(chatId, params = {}) {
        return await (0, helpers_1.evaluateAndReturn)(this.page, ({ chatId, params }) => WAPI.getMessages(chatId, params), { chatId, params: params });
    }
    /**
     * Decrypts message file
     * @param message Message object
     * @returns Decrypted file buffer (`null` otherwise)
     */
    async decryptFile(message) {
        const mediaUrl = message.clientUrl || message.deprecatedMms3Url;
        const options = (0, decrypt_1.makeOptions)(WAuserAgente_1.useragentOverride);
        if (!mediaUrl)
            throw new Error('message is missing critical data (`mediaUrl`) needed to download the file.');
        let haventGottenImageYet = true;
        let res;
        try {
            while (haventGottenImageYet) {
                res = await axios_1.default.get(mediaUrl.trim(), options);
                if (res.status == 200) {
                    haventGottenImageYet = false;
                }
                else {
                    await (0, decrypt_1.timeout)(2000);
                }
            }
        }
        catch (error) {
            throw 'Error trying to download the file.';
        }
        const buff = Buffer.from(res.data, 'binary');
        return (0, decrypt_1.magix)(buff, message.mediaKey, message.type, message.size);
    }
    async decryptAndSaveFile(message, savePath) {
        const mediaUrl = message.clientUrl || message.deprecatedMms3Url;
        if (!mediaUrl) {
            throw new Error('Message is missing critical data needed to download the file.');
        }
        try {
            const tempSavePath = savePath + '.encrypted';
            await this.downloadEncryptedFile(mediaUrl.trim(), tempSavePath);
            const inputReadStream = fs.createReadStream(tempSavePath);
            const outputWriteStream = fs.createWriteStream(savePath);
            const decryptedStream = (0, decrypt_1.newMagix)(message.mediaKey, message.type, message.size);
            inputReadStream.pipe(decryptedStream).pipe(outputWriteStream);
            await new Promise((resolve, reject) => {
                outputWriteStream.on('finish', () => {
                    console.log(`Deciphering complete. Deleting the encrypted file: ${tempSavePath}`);
                    fs.unlink(tempSavePath, (error) => {
                        if (error) {
                            console.error(`Error deleting the input file: ${tempSavePath}`, error);
                            reject(error);
                        }
                        else {
                            console.log('Encrypted file deleted successfully');
                            resolve();
                        }
                    });
                });
                outputWriteStream.on('error', (error) => {
                    console.error(`Error during writing file: ${savePath}`, error);
                    reject(error);
                });
                decryptedStream.on('error', (error) => {
                    console.error('An error occurred while decrypting the file', error);
                    reject(error);
                });
            });
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Rejects a call received via WhatsApp
     * @param callId string Call ID, if not passed, all calls will be rejected
     * @returns Number of rejected calls
     */
    async rejectCall(callId) {
        return await (0, helpers_1.evaluateAndReturn)(this.page, ({ callId }) => WPP.call.rejectCall(callId), {
            callId,
        });
    }
}
exports.Whatsapp = Whatsapp;
