"use strict";
/*
 * This file is part of WPPConnect.
 *
 * WPPConnect is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * WPPConnect is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with WPPConnect.  If not, see <https://www.gnu.org/licenses/>.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SenderLayer = void 0;
const path = __importStar(require("path"));
const ffmpeg_1 = require("../../utils/ffmpeg");
const helpers_1 = require("../helpers");
const filename_from_mimetype_1 = require("../helpers/filename-from-mimetype");
const listener_layer_1 = require("./listener.layer");
class SenderLayer extends listener_layer_1.ListenerLayer {
    constructor(page, session, options) {
        super(page, session, options);
        this.page = page;
    }
    /**
     * Automatically sends a link with the auto generated link preview. You can also add a custom message to be added.
     *
     * Deprecated: please use {@link sendText}
     *
     * @category Chat
     * @deprecated
     * @param chatId
     * @param url string A link, for example for youtube. e.g https://www.youtube.com/watch?v=Zi_XLOBDo_Y&list=RDEMe12_MlgO8mGFdeeftZ2nOQ&start_radio=1
     * @param text custom text as the message body, this includes the link or will be attached after the link
     */
    async sendLinkPreview(chatId, url, text = '') {
        const message = text.includes(url) ? text : `${url}\n${text}`;
        const result = await (0, helpers_1.evaluateAndReturn)(this.page, ({ chatId, message }) => {
            return WPP.chat.sendTextMessage(chatId, message, { linkPreview: true });
        }, { chatId, message });
        return result;
    }
    /**
     * Sends a text message to given chat
     * @category Chat
     * @param to chat id: xxxxx@us.c
     * @param content text message
     *
     * @example
     * ```javascript
     * // Simple message
     * client.sendText('<number>@c.us', 'A simple message');
     *
     * // A message with reply
     * client.sendText('<number>@c.us', 'A simple message', {
     *  quotedMsg: 'true_...@c.us_3EB01DE65ACC6_out'
     * });
     *
     * // With buttons
     * client.sendText('<number>@c.us', 'WPPConnect message with buttons', {
     *    useTemplateButtons: true, // False for legacy
     *    buttons: [
     *      {
     *        url: 'https://wppconnect.io/',
     *        text: 'WPPConnect Site'
     *      },
     *      {
     *        phoneNumber: '+55 11 22334455',
     *        text: 'Call me'
     *      },
     *      {
     *        id: 'your custom id 1',
     *        text: 'Some text'
     *      },
     *      {
     *        id: 'another id 2',
     *        text: 'Another text'
     *      }
     *    ],
     *    title: 'Title text' // Optional
     *    footer: 'Footer text' // Optional
     * });
     * ```
     */
    async sendText(to, content, options) {
        const sendResult = await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, content, options }) => WPP.chat.sendTextMessage(to, content, {
            ...options,
            waitForAck: true,
        }), { to, content, options: options });
        // I don't know why the evaluate is returning undefined for direct call
        // To solve that, I added `JSON.parse(JSON.stringify(<message>))` to solve that
        const result = (await (0, helpers_1.evaluateAndReturn)(this.page, async ({ messageId }) => {
            return JSON.parse(JSON.stringify(await WAPI.getMessageById(messageId)));
        }, { messageId: sendResult.id }));
        if (result['erro'] == true) {
            throw result;
        }
        return result;
    }
    /**
     * Sends a pix message to given chat
     * @category Chat
     * @param to chat id: xxxxx@us.c
     * @param content pix message
     *
     * @example
     * ```javascript
     * // Simple message
     * client.sendPix('<number>@c.us', {
            keyType: 'PHONE',
            name: 'WPPCONNECT-TEAM',
            key: '+5567123456789',
            instructions: 'teste',
          });
     * ```
     */
    async sendPixKey(to, params, options) {
        const sendResult = await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, params, options }) => WPP.chat.sendPixKeyMessage(to, params, {
            ...options,
            waitForAck: true,
        }), { to, params, options: options });
        // I don't know why the evaluate is returning undefined for direct call
        // To solve that, I added `JSON.parse(JSON.stringify(<message>))` to solve that
        const result = (await (0, helpers_1.evaluateAndReturn)(this.page, async ({ messageId }) => {
            return JSON.parse(JSON.stringify(await WAPI.getMessageById(messageId)));
        }, { messageId: sendResult.id }));
        if (result['erro'] == true) {
            throw result;
        }
        return result;
    }
    /**
     *
     * @category Chat
     * @param chat
     * @param content
     * @param options
     * @returns
     */
    async sendMessageOptions(chat, content, options) {
        const messageId = await (0, helpers_1.evaluateAndReturn)(this.page, ({ chat, content, options }) => {
            return WAPI.sendMessageOptions(chat, content, options);
        }, { chat, content, options });
        const result = (await (0, helpers_1.evaluateAndReturn)(this.page, (messageId) => WAPI.getMessageById(messageId), messageId));
        return result;
    }
    /**
     * Sends image message
     * @category Chat
     * @param to Chat id
     * @param filePath File path or http link
     * @param filename
     * @param caption
     * @param quotedMessageId Quoted message id
     * @param isViewOnce Enable single view
     */
    async sendImage(to, filePath, filename, caption, quotedMessageId, isViewOnce, options) {
        let base64 = await (0, helpers_1.downloadFileToBase64)(filePath, [
            'image/gif',
            'image/png',
            'image/jpg',
            'image/jpeg',
            'image/webp',
        ]);
        if (!base64) {
            base64 = await (0, helpers_1.fileToBase64)(filePath);
        }
        if (!base64) {
            const obj = {
                erro: true,
                to: to,
                text: 'No such file or directory, open "' + filePath + '"',
            };
            throw obj;
        }
        if (!filename) {
            filename = path.basename(filePath);
        }
        return await this.sendImageFromBase64(to, base64, filename, caption, quotedMessageId, isViewOnce, options?.mentionedList, options || {});
    }
    /**
     * Sends image message
     * @category Chat
     * @param to ID of the chat to send the image to
     * @param base64 A base64-encoded data URI (with mime type)
     * @param filename
     * @param caption
     * @param quotedMessageId Quoted message id
     * @param isViewOnce Enable single view
     * @param mentionedList
     * @example
     * ```javascript
     * const base64picture = "/9j/4AA[...]VZoCn9Lp//Z"
     * await client.sendImageFromBase64("120[...]381@g.us'", "data:image/png;base64," + base64picture, "picture.png")
     * ```
     */
    async sendImageFromBase64(to, base64, filename, caption, quotedMessageId, isViewOnce, mentionedList, options) {
        let mimeType = (0, helpers_1.base64MimeType)(base64);
        if (!mimeType) {
            const obj = {
                erro: true,
                to: to,
                text: 'Invalid base64!',
            };
            throw obj;
        }
        if (!mimeType.includes('image')) {
            const obj = {
                erro: true,
                to: to,
                text: 'Not an image, allowed formats png, jpeg and webp',
            };
            throw obj;
        }
        filename = (0, filename_from_mimetype_1.filenameFromMimeType)(filename, mimeType);
        const result = await (0, helpers_1.evaluateAndReturn)(this.page, async ({ to, base64, filename, caption, quotedMessageId, isViewOnce, mentionedList, options, }) => {
            const result = await WPP.chat.sendFileMessage(to, base64, {
                type: 'image',
                isViewOnce,
                messageId: options?.msgId,
                filename,
                caption,
                quotedMsg: quotedMessageId,
                waitForAck: true,
                detectMentioned: true,
                mentionedList: mentionedList,
            });
            return {
                ack: result.ack,
                id: result.id,
                sendMsgResult: await result.sendMsgResult,
            };
        }, {
            to,
            base64,
            filename,
            caption,
            quotedMessageId,
            isViewOnce,
            mentionedList,
            options,
        });
        return result;
    }
    /**
     * Sends message with thumbnail
     *
     * @deprecated: please use {@link sendText} with options
     *
     * @deprecated
     * @category Chat
     * @param pathOrBase64
     * @param url
     * @param title
     * @param description
     * @param chatId
     */
    async sendMessageWithThumb(pathOrBase64, url, title, description, chatId) {
        let base64 = '';
        if (pathOrBase64.startsWith('data:')) {
            base64 = pathOrBase64;
        }
        else {
            let fileContent = await (0, helpers_1.downloadFileToBase64)(pathOrBase64, [
                'image/gif',
                'image/png',
                'image/jpg',
                'image/jpeg',
                'image/webp',
            ]);
            if (!fileContent) {
                fileContent = await (0, helpers_1.fileToBase64)(pathOrBase64);
            }
            if (fileContent) {
                base64 = fileContent;
            }
        }
        if (!base64) {
            const error = new Error('Empty or invalid file or base64');
            Object.assign(error, {
                code: 'empty_file',
            });
            throw error;
        }
        const mimeInfo = (0, helpers_1.base64MimeType)(base64);
        if (!mimeInfo || !mimeInfo.includes('image')) {
            const error = new Error('Not an image, allowed formats png, jpeg, webp and gif');
            Object.assign(error, {
                code: 'invalid_image',
            });
            throw error;
        }
        const thumbnail = base64.replace(/^data:image\/(png|jpe?g|webp|gif);base64,/, '');
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ thumbnail, url, title, description, chatId }) => WPP.chat.sendTextMessage(chatId, url, {
            linkPreview: {
                thumbnail: thumbnail,
                canonicalUrl: url,
                description: description,
                matchedText: url,
                title: title,
                richPreviewType: 0,
                doNotPlayInline: true,
            },
        }), {
            thumbnail,
            url,
            title,
            description,
            chatId,
        });
    }
    /**
     * Replies to given mesage id of given chat id
     *
     * Deprecated: Please, use sendText with quotedMsg option
     *
     * @deprecated
     *
     * @category Chat
     * @param to Chat id
     * @param content Message body
     * @param quotedMsg Message id to reply to.
     */
    async reply(to, content, quotedMsg) {
        const result = await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, content, quotedMsg }) => {
            return WPP.chat.sendTextMessage(to, content, { quotedMsg });
        }, { to, content, quotedMsg });
        const message = (await (0, helpers_1.evaluateAndReturn)(this.page, (messageId) => WAPI.getMessageById(messageId), result.id));
        if (message['erro'] == true) {
            throw message;
        }
        return message;
    }
    /**
     * Sends ptt audio
     * base64 parameter should have mime type already defined
     * @category Chat
     * @param to Chat id
     * @param base64 base64 data
     * @param filename
     * @param caption
     * @param quotedMessageId Quoted message id
     * @param messageId Set the id for this message
     * @param isPtt Set as ptt audio
     */
    async sendPttFromBase64(to, base64, filename, caption, quotedMessageId, messageId, isPtt = true) {
        const result = await (0, helpers_1.evaluateAndReturn)(this.page, async ({ to, base64, filename, caption, quotedMessageId, messageId, isPtt, }) => {
            const result = await WPP.chat.sendFileMessage(to, base64, {
                type: 'audio',
                isPtt: isPtt,
                filename,
                caption,
                quotedMsg: quotedMessageId,
                waitForAck: true,
                messageId: messageId,
            });
            return {
                ack: result.ack,
                id: result.id,
                sendMsgResult: await result.sendMsgResult,
            };
        }, { to, base64, filename, caption, quotedMessageId, messageId, isPtt });
        return result;
    }
    /**
     * Sends ptt audio from path
     * @category Chat
     * @param to Chat id
     * @param filePath File path
     * @param filename
     * @param caption
     * @param quotedMessageId Quoted message id
     * @param messageId Set the id for this message
     * @param isPtt Set as ptt audio
     */
    async sendPtt(to, filePath, filename, caption, quotedMessageId, messageId, isPtt = true) {
        return new Promise(async (resolve, reject) => {
            let base64 = await (0, helpers_1.downloadFileToBase64)(filePath, [/^audio/]), obj;
            if (!base64) {
                base64 = await (0, helpers_1.fileToBase64)(filePath);
            }
            if (!base64) {
                obj = {
                    erro: true,
                    to: to,
                    text: 'No such file or directory, open "' + filePath + '"',
                };
                return reject(obj);
            }
            if (!filename) {
                filename = path.basename(filePath);
            }
            return this.sendPttFromBase64(to, base64, filename, caption, quotedMessageId, messageId, isPtt)
                .then(resolve)
                .catch(reject);
        });
    }
    /**
     * Sends file
     * base64 parameter should have mime type already defined
     *
     * Deprecated: please use sendFile with options: sendFile(to, content, options)
     *
     * @deprecated
     *
     * @category Chat
     * @param chatId Chat id
     * @param base64 base64 data
     * @param filename
     * @param caption
     */
    async sendFileFromBase64(chatId, base64, filename, caption) {
        return this.sendFile(chatId, base64, filename, caption);
    }
    async sendFile(to, pathOrBase64, nameOrOptions, caption) {
        let options = { type: 'auto-detect' };
        if (typeof nameOrOptions === 'string') {
            options.filename = nameOrOptions;
            options.caption = caption;
        }
        else if (typeof nameOrOptions === 'object') {
            options = nameOrOptions;
        }
        let base64 = '';
        if (pathOrBase64.startsWith('data:')) {
            base64 = pathOrBase64;
        }
        else {
            let fileContent = await (0, helpers_1.downloadFileToBase64)(pathOrBase64);
            if (!fileContent) {
                fileContent = await (0, helpers_1.fileToBase64)(pathOrBase64);
            }
            if (fileContent) {
                base64 = fileContent;
            }
            if (!options.filename) {
                options.filename = path.basename(pathOrBase64);
            }
        }
        if (!base64) {
            const error = new Error('Empty or invalid file or base64');
            Object.assign(error, {
                code: 'empty_file',
            });
            throw error;
        }
        return (0, helpers_1.evaluateAndReturn)(this.page, async ({ to, base64, options }) => {
            const result = await WPP.chat.sendFileMessage(to, base64, options);
            return {
                ack: result.ack,
                id: result.id,
                sendMsgResult: await result.sendMsgResult,
            };
        }, { to, base64, options: options });
    }
    /**
     * Sends a video to given chat as a gif, with caption or not
     * @category Chat
     * @param to Chat id
     * @param filePath File path
     * @param filename
     * @param caption
     */
    async sendVideoAsGif(to, filePath, filename, caption) {
        let base64 = await (0, helpers_1.downloadFileToBase64)(filePath), obj;
        if (!base64) {
            base64 = await (0, helpers_1.fileToBase64)(filePath);
        }
        if (!base64) {
            obj = {
                erro: true,
                to: to,
                text: 'No such file or directory, open "' + filePath + '"',
            };
            throw obj;
        }
        if (!filename) {
            filename = path.basename(filePath);
        }
        return this.sendVideoAsGifFromBase64(to, base64, filename, caption);
    }
    /**
     * Sends a video to given chat as a gif, with caption or not, using base64
     * @category Chat
     * @param to chat id xxxxx@us.c
     * @param base64 base64 data:video/xxx;base64,xxx
     * @param filename string xxxxx
     * @param caption string xxxxx
     */
    async sendVideoAsGifFromBase64(to, base64, filename, caption, quotedMessageId) {
        const result = await (0, helpers_1.evaluateAndReturn)(this.page, async ({ to, base64, filename, caption, quotedMessageId }) => {
            const result = await WPP.chat.sendFileMessage(to, base64, {
                type: 'video',
                isGif: true,
                filename,
                caption,
                quotedMsg: quotedMessageId,
                waitForAck: true,
            });
            return {
                ack: result.ack,
                id: result.id,
                sendMsgResult: await result.sendMsgResult,
            };
        }, { to, base64, filename, caption, quotedMessageId });
        return result;
    }
    /**
     * Sends a video to given chat as a gif, with caption or not, using base64
     * @category Chat
     * @param to Chat id
     * @param filePath File path
     * @param filename
     * @param caption
     */
    async sendGif(to, filePath, filename, caption) {
        let base64 = await (0, helpers_1.downloadFileToBase64)(filePath), obj;
        if (!base64) {
            base64 = await (0, helpers_1.fileToBase64)(filePath);
        }
        if (!base64) {
            obj = {
                erro: true,
                to: to,
                text: 'No such file or directory, open "' + filePath + '"',
            };
            throw obj;
        }
        if (!filename) {
            filename = path.basename(filePath);
        }
        return this.sendGifFromBase64(to, base64, filename, caption);
    }
    /**
     * Sends a video to given chat as a gif, with caption or not, using base64
     * @category Chat
     * @param to chat id xxxxx@us.c
     * @param base64 base64 data:video/xxx;base64,xxx
     * @param filename string xxxxx
     * @param caption string xxxxx
     */
    async sendGifFromBase64(to, base64, filename, caption) {
        base64 = await (0, ffmpeg_1.convertToMP4GIF)(base64);
        return await this.sendVideoAsGifFromBase64(to, base64, filename, caption);
    }
    /**
     * Sends contact card to iven chat id
     * @category Chat
     * @param to Chat id
     * @param contactsId Example: 0000@c.us | [000@c.us, 1111@c.us]
     */
    async sendContactVcard(to, contactsId, name) {
        const result = await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, contactsId, name }) => {
            return WPP.chat.sendVCardContactMessage(to, {
                id: contactsId,
                name: name,
            });
        }, { to, contactsId, name });
        return result;
    }
    /**
     * Send a list of contact cards
     * @category Chat
     * @param to Chat id
     * @param contacts Example: | ['000@c.us', '1111@c.us', {id: '2222@c.us', name: 'Test'}]
     */
    async sendContactVcardList(to, contacts) {
        const result = await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, contacts }) => {
            return WPP.chat.sendVCardContactMessage(to, contacts);
        }, { to, contacts });
        return result;
    }
    /**
     * Forwards array of messages (could be ids or message objects)
     * @deprecated please use {@link forwardMessagesV2}
     * @category Chat
     * @param to Chat id
     * @param messages Array of messages ids to be forwarded
     * @param skipMyMessages
     * @returns array of messages ID
     */
    async forwardMessage(toChatId, msgId, options) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ toChatId, msgId, options }) => WPP.chat.forwardMessage(toChatId, msgId, options), { toChatId, msgId, options });
    }
    /**
     * Forwards array of messages (could be ids or message objects)
     * What is the difference between forwardMessage and forwardMessagesV2?
     * forwardMessage was used to forward a single message
     * forwardMessagesV2 is used to forward multiple messages
     * Also, it fixes how we pass the arguments to the whatsapp original function
     * From positional args to named args (object)
     * @category Chat
     * @param to Chat id
     * @param messages Array of messages ids to be forwarded
     * @param options
     * @returns array of messages ID
     */
    async forwardMessagesV2(toChatId, messages, options) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ toChatId, messages, options }) => WPP.chat.forwardMessages(toChatId, messages, options), { toChatId, messages, options });
    }
    /**
     * Generates sticker from the provided animated gif image and sends it (Send image as animated sticker)
     *
     * @example
     * ```javascript
     * client.sendImageAsStickerGif('000000000000@c.us', 'base64....');
     * ```
     *
     * @example
     * Send Sticker with reply
     * ```javascript
     * client.sendImageAsStickerGif('000000000000@c.us', 'base64....', {
     *     quotedMsg: 'msgId',
     * });
     * ```
     * @category Chat
     * @param pathOrBase64 image path imageBase64 A valid gif image is required. You can also send via http/https (http://www.website.com/img.gif)
     * @param to chatId '000000000000@c.us'
     */
    async sendImageAsStickerGif(to, pathOrBase64, options) {
        let base64 = '';
        if (pathOrBase64.startsWith('data:')) {
            base64 = pathOrBase64;
        }
        else {
            let fileContent = await (0, helpers_1.downloadFileToBase64)(pathOrBase64, [
                'image/gif',
                'image/webp',
            ]);
            if (!fileContent) {
                fileContent = await (0, helpers_1.fileToBase64)(pathOrBase64);
            }
            if (fileContent) {
                base64 = fileContent;
            }
        }
        if (!base64) {
            const error = new Error('Empty or invalid file or base64');
            Object.assign(error, {
                code: 'empty_file',
            });
            throw error;
        }
        const mimeInfo = (0, helpers_1.base64MimeType)(base64);
        if (!mimeInfo || !mimeInfo.includes('image')) {
            const error = new Error('Not an image, allowed formats gig and webp');
            Object.assign(error, {
                code: 'invalid_image',
            });
            throw error;
        }
        const buff = Buffer.from(base64.replace(/^data:image\/(gif|webp);base64,/, ''), 'base64');
        let obj = await (0, helpers_1.stickerSelect)(buff, 1);
        if (!obj) {
            const error = new Error('Error with sharp library, check the console log');
            Object.assign(error, {
                code: 'sharp_error',
            });
            throw error;
        }
        const { webpBase64 } = obj;
        return await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, webpBase64, options }) => {
            return WPP.chat.sendFileMessage(to, webpBase64, {
                type: 'sticker',
                ...options,
            });
        }, { to, webpBase64, options });
    }
    /**
     * Generates sticker from given image and sends it (Send Image As Sticker)
     *
     * @example
     * ```javascript
     * client.sendImageAsSticker('000000000000@c.us', 'base64....');
     * ```
     *
     * @example
     * Send Sticker with reply
     * ```javascript
     * client.sendImageAsSticker('000000000000@c.us', 'base64....', {
     *     quotedMsg: 'msgId',
     * });
     * ```
     *
     * @category Chat
     * @param pathOrBase64 image path imageBase64 A valid png, jpg and webp image is required. You can also send via http/https (http://www.website.com/img.gif)
     * @param to chatId '000000000000@c.us'
     */
    async sendImageAsSticker(to, pathOrBase64, options) {
        let base64 = '';
        if (pathOrBase64.startsWith('data:')) {
            base64 = pathOrBase64;
        }
        else {
            let fileContent = await (0, helpers_1.downloadFileToBase64)(pathOrBase64, [
                'image/gif',
                'image/png',
                'image/jpg',
                'image/jpeg',
                'image/webp',
            ]);
            if (!fileContent) {
                fileContent = await (0, helpers_1.fileToBase64)(pathOrBase64);
            }
            if (fileContent) {
                base64 = fileContent;
            }
        }
        if (!base64) {
            const error = new Error('Empty or invalid file or base64');
            Object.assign(error, {
                code: 'empty_file',
            });
            throw error;
        }
        const mimeInfo = (0, helpers_1.base64MimeType)(base64);
        if (!mimeInfo || !mimeInfo.includes('image')) {
            const error = new Error('Not an image, allowed formats png, jpeg, webp and gif');
            Object.assign(error, {
                code: 'invalid_image',
            });
            throw error;
        }
        const buff = Buffer.from(base64.replace(/^data:image\/(png|jpe?g|webp|gif);base64,/, ''), 'base64');
        let obj = await (0, helpers_1.stickerSelect)(buff, 0);
        if (!obj) {
            const error = new Error('Error with sharp library, check the console log');
            Object.assign(error, {
                code: 'sharp_error',
            });
            throw error;
        }
        const { webpBase64 } = obj;
        return await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, webpBase64, options }) => {
            return WPP.chat.sendFileMessage(to, webpBase64, {
                type: 'sticker',
                ...options,
            });
        }, { to, webpBase64, options });
    }
    async sendLocation(to, latitudeOrOptions, longitude, title) {
        const options = typeof latitudeOrOptions === 'string'
            ? {
                lat: latitudeOrOptions,
                lng: longitude,
                title: title,
            }
            : latitudeOrOptions;
        return await (0, helpers_1.evaluateAndReturn)(this.page, async ({ to, options }) => {
            const result = await WPP.chat.sendLocationMessage(to, options);
            return {
                ack: result.ack,
                id: result.id,
                sendMsgResult: await result.sendMsgResult,
            };
        }, { to, options: options });
    }
    /**
     * Sets a chat status to seen. Marks all messages as ack: 3
     * @category Chat
     * @param chatId chat id: xxxxx@us.c
     */
    async sendSeen(chatId) {
        return (0, helpers_1.evaluateAndReturn)(this.page, (chatId) => WPP.chat.markIsRead(chatId), chatId);
    }
    /**
     * Sets an audio or image view once. Marks message as played
     * @category Chat
     * @param msgId Message id: xxxxx@us.c
     */
    async markPlayed(msgId) {
        return (0, helpers_1.evaluateAndReturn)(this.page, (msgId) => WPP.chat.markPlayed(msgId), msgId);
    }
    /**
     * Starts typing ('Typing...' state)
     *
     * @example
     * ```javascript
     * // Keep sending typing state, use stopTyping to finish
     * await client.startTyping('[number]@c.us');
     *
     * // Keep sending typing state for 5 seconds
     * await client.startTyping('[number]@c.us', 5000);
     * ```
     * @category Chat
     * @param to Chat Id
     * @param duration Duration in milliseconds
     */
    async startTyping(to, duration) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ to, duration }) => WPP.chat.markIsComposing(to, duration), {
            to,
            duration,
        });
    }
    /**
     * Stops typing ('Typing...' state)
     * @category Chat
     * @param to Chat Id
     */
    async stopTyping(to) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ to }) => WPP.chat.markIsPaused(to), {
            to,
        });
    }
    /**
     * Starts recording ('Recording...' state)
     * @example
     * ```javascript
     * // Keep sending recording state, use `stopRecording` to finish
     * await client.startRecording('[number]@c.us');
     *
     * // Keep sending typing state for 5 seconds
     * await client.startRecording('[number]@c.us', 5000);
     * ```
     * @category Chat
     * @param to Chat Id
     * @param duration Duration in milliseconds
     */
    async startRecording(to, duration) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ to, duration }) => WPP.chat.markIsRecording(to, duration), {
            to,
            duration,
        });
    }
    /**
     * Stops recording ('Recording...' state)
     * @deprecated please use {@link stopRecording} this function will be removed in future releases
     * @category Chat
     * @param to Chat Id
     */
    async stopRecoring(to) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ to }) => WPP.chat.markIsPaused(to), {
            to,
        });
    }
    /**
     * Stops recording ('Recording...' state)
     * @category Chat
     * @param to Chat Id
     */
    async stopRecording(to) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ to }) => WPP.chat.markIsPaused(to), {
            to,
        });
    }
    /**
     * Update your online presence
     * @category Chat
     * @param online true for available presence and false for unavailable
     */
    async setOnlinePresence(online = true) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ online }) => WPP.conn.markAvailable(online), {
            online,
        });
    }
    /**
     * Sends text with tags
     * @category Chat
     */
    async sendMentioned(to, message, mentioned) {
        return await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, message, mentioned }) => WPP.chat.sendTextMessage(to, message, {
            detectMentioned: true,
            mentionedList: mentioned,
        }), { to, message, mentioned });
    }
    /**
     * Sends a list message
     *
     * ```typescript
     *   // Example
     *   client.sendListMessage('<number>@c.us', {
     *     buttonText: 'Click here',
     *     description: 'Choose one option',
     *     sections: [
     *       {
     *         title: 'Section 1',
     *         rows: [
     *           {
     *             rowId: 'my_custom_id',
     *             title: 'Test 1',
     *             description: 'Description 1',
     *           },
     *           {
     *             rowId: '2',
     *             title: 'Test 2',
     *             description: 'Description 2',
     *           },
     *         ],
     *       },
     *     ],
     *   });
     * ```
     *
     * @category Chat
     */
    async sendListMessage(to, options) {
        const sendResult = await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, options }) => WPP.chat.sendListMessage(to, options), {
            to,
            options: options,
        });
        // I don't know why the evaluate is returning undefined for direct call
        // To solve that, I added `JSON.parse(JSON.stringify(<message>))` to solve that
        const result = (await (0, helpers_1.evaluateAndReturn)(this.page, async ({ messageId }) => {
            return JSON.parse(JSON.stringify(await WAPI.getMessageById(messageId)));
        }, { messageId: sendResult.id }));
        if (result['erro'] == true) {
            throw result;
        }
        return result;
    }
    /**
     * Send a create poll message
     *
     * @example
     * ```javascript
     * // Single pool
     * client.sendPollMessage(
     *  '[number]@g.us',
     *  'A poll name',
     *  ['Option 1', 'Option 2', 'Option 3']
     * );
     * ```
     * // Selectable Count
     * ```javascript
     * // Single pool
     * client.sendPollMessage(
     *  '[number]@g.us',
     *  'A poll name',
     *  ['Option 1', 'Option 2', 'Option 3'],
     *  {
     *    selectableCount: 1,
     *  }
     * );
     * ```
     *
     * @category Chat
     */
    async sendPollMessage(chatId, name, choices, options) {
        const sendResult = await (0, helpers_1.evaluateAndReturn)(this.page, ({ chatId, name, choices, options }) => WPP.chat.sendCreatePollMessage(chatId, name, choices, options), {
            chatId,
            name,
            choices,
            options: options,
        });
        // I don't know why the evaluate is returning undefined for direct call
        // To solve that, I added `JSON.parse(JSON.stringify(<message>))` to solve that
        const result = (await (0, helpers_1.evaluateAndReturn)(this.page, async ({ messageId }) => {
            return JSON.parse(JSON.stringify(await WAPI.getMessageById(messageId)));
        }, { messageId: sendResult.id }));
        if (result['erro'] == true) {
            throw result;
        }
        return result;
    }
    /**
     * Sets the chat state
     * Deprecated in favor of Use startTyping or startRecording functions
     * @category Chat
     * @param chatState
     * @param chatId
     * @deprecated Deprecated in favor of Use startTyping or startRecording functions
     */
    async setChatState(chatId, chatState) {
        return await (0, helpers_1.evaluateAndReturn)(this.page, ({ chatState, chatId }) => {
            WAPI.sendChatstate(chatState, chatId);
        }, { chatState, chatId });
    }
    /**
     * Send reaction to message
     * @example
     * ```javascript
     * // For send Reaction, just to send emoji
     * await client.sendReactionToMessage('[number]@c.us', 'ðŸ¤¯');
     *
     * // to remove reacition
     * await client.startRecording('[number]@c.us', false);
     * ```
     * @category Chat
     * @param to Chat Id
     * @param duration Duration in milliseconds
     */
    async sendReactionToMessage(msgId, reaction) {
        return (0, helpers_1.evaluateAndReturn)(this.page, ({ msgId, reaction }) => WPP.chat.sendReactionToMessage(msgId, reaction), {
            msgId,
            reaction,
        });
    }
    /**
     * Send an order message
     * To send (prices, tax, shipping or discount), for example: USD 12.90, send them without dots or commas, like: 12900
     *
     * @example
     * ```javascript
     * // Send an order with a product
     * client.sendOrderMessage('[number]@c.us', [
     *   { type: 'product', id: '67689897878', qnt: 2 },
     *   { type: 'product', id: '37878774457', qnt: 1 },
     * ]
     *
     * // Send Order with a custom item
     * client.sendOrderMessage('[number]@c.us', [
     *   { type: 'custom', name: 'Item de cost test', price: 120000, qnt: 2 },
     * ]
     *
     * // Send Order with custom options
     * client.sendOrderMessage('[number]@c.us', [
     *   { type: 'product', id: '37878774457', qnt: 1 },
     *   { type: 'custom', name: 'Item de cost test', price: 120000, qnt: 2 },
     * ],
     * { tax: 10000, shipping: 4000, discount: 10000 }
     * ```
     *
     * @category Chat
     */
    async sendOrderMessage(to, items, options) {
        const sendResult = await (0, helpers_1.evaluateAndReturn)(this.page, ({ to, items, options }) => WPP.chat.sendChargeMessage(to, items, options), {
            to,
            items,
            options,
        });
        // I don't know why the evaluate is returning undefined for direct call
        // To solve that, I added `JSON.parse(JSON.stringify(<message>))` to solve that
        const result = (await (0, helpers_1.evaluateAndReturn)(this.page, async ({ messageId }) => {
            return JSON.parse(JSON.stringify(await WAPI.getMessageById(messageId)));
        }, { messageId: sendResult.id }));
        if (result['erro'] == true) {
            throw result;
        }
        return result;
    }
}
exports.SenderLayer = SenderLayer;
